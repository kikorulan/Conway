/*=============================================================================

  GRIDRT: Implementation for the header file gridRT.h

  Copyright (C) 2017 Kiko RulÂ·lan, Marta M. Betcke

  See LICENSE.txt in the top level directory for details.

=============================================================================*/

#include "mpBasicTypes.h"
#include "source.h"
#include "gridRT.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <cstdlib>
#include <cmath>
#include <vector>
#include <memory>
#include <armadillo>


using namespace arma;

namespace RayTracing {

/*=======================================================================
====== Constructors
=========================================================================*/

// Constructor for given dimensions 
GridRT::GridRT(int const& Nx, double const& dx, int const& Ny, double const& dy) {
    // Check input values
    if (Nx < 1 || Ny < 1 || dx <= 0 || dy <= 0)
        throw std::invalid_argument("GridRT not created. Invalid value(s) for grid dimensions.\n");

    setDimensions(Nx, dx, Ny, dy);
    // Message: gridRT created
    std::cout << "GridRT created." << std::endl;
    getDimensions();
}

// Constructor from input file stream iFile 
GridRT::GridRT(std::string &iFileName){
    std::ifstream iFile;
    iFile.open(iFileName);
    if (iFile.fail()){
        std::ostringstream msg;
        msg << "GridRT(): Opening file '" << iFileName
            << "' failed, it either doesn't exist or is not accessible.";
        throw std::runtime_error(msg.str());
    }
    int Nx = 0, Ny = 0;
    double dx = 0, dy = 0;

    std::string str;
    std::stringstream ss;
    getline(iFile, str);
    ss << str;
    ss >> Nx >> Ny;
    ss.clear();
    getline(iFile, str);
    ss << str;
    ss >> dx >> dy;
    ss.clear();

    // Check input values
    if (Nx < 1 || Ny < 1 || dx <= 0 || dy <= 0)
        throw std::invalid_argument("GridRT not created. Invalid value(s) for grid dimensions.\n");

    setDimensions(Nx, dx, Ny, dy);
    // Message: gridRT created
    std::cout << "GridRT created." << std::endl;
    getDimensions();
}

/*=======================================================================
====== Setters
=========================================================================*/
// Set the dimensions of the GRIDRT domain
void GridRT::setDimensions(int const& Nx, double const& dx, int const& Ny, double const& dy){
    // Assign values
    GridRT::Nx = Nx; // Assign Nx points at the x axis
    GridRT::Ny = Ny; // Assign Ny points at the y axis
    GridRT::dx = dx; // Spacial separation at the x axis
    GridRT::dy = dy; // Spacial separation at the y axis
    c.reset(new mat(Nx, Ny)); // Create c matrix 
    (*c).fill(datum::nan);
    n.reset(new mat(Nx, Ny)); // Create n matrix
    (*n).fill(datum::nan);
}

// Set c equal to the given matrix
void GridRT::setC(matP &M){
    // Check input values
    if (M->min() <= 0)
        throw std::invalid_argument("Sound speed not assigned due to invalid data. Values should be > 0.\n");
    c.reset(M.release());
    n.reset(new mat(1.0/(*c)));
}

/*=======================================================================
====== Getters for c and n
=========================================================================*/
// Get the dimensions at the standard output
void GridRT::getDimensions(void){
    std::cout << "Dimensions:" << std::endl;
    std::cout << "    Nx: " << Nx << std::endl;
    std::cout << "    Ny: " << Ny << std::endl;
    std::cout << "    dx: " << dx << std::endl;
    std::cout << "    dy: " << dy << std::endl;
}

// Get Nx
int GridRT::getNX(void) { return Nx; }

// Get Ny
int GridRT::getNY(void) { return Ny; }

// Get dx
double GridRT::getDX(void) { return dx; }

// Get dy
double GridRT::getDY(void) { return dy; }

// Get c at the standard output
void GridRT::getC(void) { std::cout << *c << std::endl; }

// Get n at the standard output
void GridRT::getN(void) { std::cout << *n << std::endl; }

// Get n for the given coordinate points
rowvecP GridRT::getN(matIP &coord) {
    rowvecP n(new rowvec(coord->n_cols));
    (*n).fill(datum::nan);
    for (int i = 0; i < coord->n_cols; i++){
        if((*coord)(0, i) > -1)
            (*n)(i) = (*GridRT::n)((*coord)(0, i), (*coord)(1, i));
    }
    return n;
}

// Get n for the given coordinate points
rowvecP GridRT::getN(rowvecIP &coordX, rowvecIP &coordY) {
    rowvecP n(new rowvec(coordX->n_cols));
    (*n).fill(datum::nan);
    for (int i = 0; i < coordX->n_cols; i++){
        if((*coordX)(i) > -1)
            (*n)(0, i) = (*GridRT::n)((*coordX)(i), (*coordY)(i));
    }
    return n;
}

// Get the number of sources
int GridRT::getNSources(void){
    return source.size();
}


/*=======================================================================
====== Create new source
=========================================================================*/

void GridRT::newSource(vecP &x0, int const& nRays, double const& angleMin, double const& angleMax, double const& step, double const& tauMax){
    // Convert x0 to matrix to find coordinates
    matP x0M(new mat(2, 1));
    (*x0M)(0, 0) = (*x0)(0);
    (*x0M)(1, 0) = (*x0)(1);
    // Find coordinates
    matIP coord(findCoordinates(x0M).release());
    double n = (*getN(coord))(0);
    matP grad(gradN(coord).release());
    vecP nGn(new vec(2));
    (*nGn)(0) = (*grad)(0, 0)*n;
    (*nGn)(1) = (*grad)(1, 0)*n;

    // Message: source created
    std::cout << "Source " << source.size() << ":" << std::endl;
    std::unique_ptr<Source> source0;
    // Check if coordinates for source position are valid
    if ((*coord)(0) == -1){
        std::cerr << "    Source could not be created. Source position outside the domain." << std::endl;
        std::cerr << "    Creating null source to keep source's indeces..." << std::endl;
        source0.reset(new Source(x0, 1, 0., 1., n, nGn, 1., 1.));
    }
    else {
        // Source throws an exception if input values are invalid
        try{
            source0.reset(new Source(x0, nRays, angleMin, angleMax, n, nGn, step, tauMax));
        } catch (const std::exception &e){
            std::cerr << e.what();
            std::cerr << "    Creating null source to keep source's indeces..." << std::endl;
            source0.reset(new Source(x0, 1, 0., 1., n, nGn, 1., 1.));
        }
    }
    source.push_back(std::move(source0));

}

/*============================================================================
==============                                            ====================
==============         Compute the ray trajectories       ====================
==============                                            ====================
==============================================================================*/

// Find the coordinates in the grid for the given points
matIP GridRT::findCoordinates(matP &point){
    // Round to nearest integer
    rowvec rowX = round((*point).row(0)/dx);  // X coordinate
    rowvec rowY = round((*point).row(1)/dy);  // Y coordinate
    // Delete points outside the domain: assign -1 to x coordinate
    rowX.elem(find(rowX < 0)).fill(-1); 
    rowX.elem(find(rowX > Nx - 1)).fill(-1);
    rowX.elem(find_nonfinite(rowX)).fill(-1);
    rowX.elem(find(rowY < 0)).fill(-1); 
    rowX.elem(find(rowY > Ny - 1)).fill(-1);
    rowX.elem(find_nonfinite(rowY)).fill(-1);
    // Create output matrix
    int nCols = point->n_cols;
    mat coord = mat(2, nCols);
    coord.row(0) = rowX;
    coord.row(1) = rowY;
    // Convert to integer
    matIP coordInt(new matI(2, nCols));
    *coordInt = conv_to<matI>::from(coord);
    return coordInt;
}

// Compute the gradient of n at the given coordinate points
matP GridRT::gradN(matIP &coord){
    // Create output matrix
    int nCols = (*coord).n_cols;
    matP grad(new mat(2, nCols));
    // Obtain the coordinates in row form
    rowvecIP xCoord(new rowvecI(nCols));
    rowvecIP yCoord(new rowvecI(nCols));
    (*xCoord) = (*coord).row(0);
    (*yCoord) = (*coord).row(1);
    // X component
    rowvecIP xNext(new rowvecI(nCols));
    rowvecIP xPrev(new rowvecI(nCols));
    (*xNext) = (*xCoord) + 1;
    xNext->elem(find((*xNext) == Nx)).fill(Nx - 1); // superior x boundary
    xNext->elem(find((*xNext) == 0)).fill(-1); // correct outside domain values
    (*xPrev) = (*xCoord) - 1;
    xPrev->elem(find((*xPrev) == -1)).fill(0); // inferior x boundary
    grad->row(0) = ((*getN(xNext, yCoord)) - (*getN(xPrev, yCoord)))/((*xNext)-(*xPrev))/dx;
    // Y component
    rowvecIP yNext(new rowvecI(nCols));
    rowvecIP yPrev(new rowvecI(nCols));
    (*yNext) = (*yCoord) + 1;
    yNext->elem(find((*yNext) == Ny)).fill(Ny - 1); // superior y boundary
    (*yPrev) = (*yCoord) - 1;
    yPrev->elem(find((*yPrev) == -1)).fill(0); // inferior y boundary
    grad->row(1) = ((*getN(xCoord, yNext)) - (*getN(xCoord, yPrev)))/((*yNext)-(*yPrev))/dy;
    return grad;
}

// Compute the derivative of p at the given index for the given X
matP GridRT::derive(double const& tau, int const& index, matP &X, int const& nS){
    matIP coord(findCoordinates(X).release());
    matP p(move(source[nS]->getP(index)));
    matP nGn(move(source[nS]->getNGN(index)));
    double tauP = source[nS]->getTau(index);
 
    matP grad(gradN(coord).release());
    rowvec n = (*getN(coord));
    mat nMat = repmat(n, 2, 1);

    matP dp(new mat(2, X->n_cols));
    (*dp) = (*p) + (tau-tauP)*0.5*((*nGn) + nMat%(*grad));
    return dp;
}

// Compute the Runge-Kutta step at the given index for position X
matP GridRT::stepRK4(double const& tau, int const& index, matP &X, double h, int const& nS){
    matP Xn(new mat(2, X->n_cols));
    (*Xn) = (*X);
    matP k1(move(derive(tau, index, Xn, nS))); // Compute k1
    (*Xn) = (*X) + 0.5*(*k1)*h;
    matP k2(move(derive(tau, index, Xn, nS))); // Compute k2
    (*Xn) = (*X) + 0.5*(*k2)*h;
    matP k3(move(derive(tau, index, Xn, nS))); // Compute k3
    (*Xn) = (*X) + (*k3)*h;
    matP k4(move(derive(tau, index, Xn, nS))); // Compute k4

    (*Xn) = (*X) + 1.0/6*h*((*k1) + 2*(*k2) + 2*(*k3) + (*k4)); // Runge-Kutta point
    return Xn;
}

// Compute a step in the ray trajectories at the given index for the given source
void GridRT::stepSource(int const& index, int const& nS){
    matP x0(move(source[nS]->getX(index)));
    double step = source[nS]->getStep();
    double tau0 = source[nS]->getTau(index);
    matP phi0(move(source[nS]->getPhi(index)));
    // Insert x
    matP x(move(stepRK4(tau0, index, x0, step, nS)));
    source[nS]->insertX(index + 1, x);
    // Insert p
    matP p(move(derive(tau0 + step, index, x, nS)));
    source[nS]->insertP(index + 1, p);
    // Compute new coordinates
    matIP coord(move(findCoordinates(x)));
    // Insert tau
    source[nS]->insertTau(index + 1, tau0 + step);
    // Insert phi
    rowvec n = (*getN(coord));
    phi0->row(0) = phi0->row(0) + step*n%n;
    source[nS]->insertPhi(index + 1, phi0);
    // Insert nGn
    matP nGn0(move(gradN(coord)));
    (*nGn0) = (*nGn0)%repmat(n, 2, 1);
    source[nS]->insertNGN(index + 1, nGn0);
}

// Compute the ray trajectories for source nS
void GridRT::computeSource(int const& nS){
    // Message
    std::cout << "Computing ray trajectories for source " << nS << "..." << std::endl;
    int nSteps = source[nS]->getNSteps();
    int i = 0;
    matP x(move(source[nS]->getX(0)));
    while (i < nSteps-1){
        stepSource(i, nS);
        i++;
        x.reset(source[nS]->getX(i).release());
    }
    std::cout << "Source " << nS << " computed." << std::endl;
}

/*============================================================================
==============                                            ====================
==============         Load and write data                ====================
==============                                            ====================
==============================================================================*/

/*=======================================================================
====== Load data from file stream
=========================================================================*/
/* Load C matrix from input file */
void GridRT::loadC(std::string &iFileName){
    // Open input file
    std::ifstream iFile;
    iFile.open(iFileName);
    if (iFile.fail()){
        std::ostringstream msg;
        msg << "loadC(): Opening file '" << iFileName
            << "' failed, it either doesn't exist or is not accessible.";
        throw std::runtime_error(msg.str());
    }

    std::string str;
    std::stringstream ss;
    matP C; 
  
    // C matrix
    int nCol = 0, nRow = 0;
    double val;
    C.reset(new mat(Nx, Ny));
    C->fill(datum::nan);
    while(getline(iFile, str)){
        nCol = 0;
        ss << str;
        while(ss >> val){
            if (nCol < Ny && nRow < Nx)
                (*C)(nRow, nCol) = val;
            else
                throw std::invalid_argument(std::string("Error: Wrong dimension for sound speed matrix.\n"));
            nCol++;
        }
        ss.clear();
        nRow++;
    }
    
    if (nCol < Ny || nRow < Nx)
        throw std::invalid_argument(std::string("Error: Wrong dimension for sound speed matrix.\n"));

    setC(C);
    iFile.close();
}

/* Load Sources from given input file */
void GridRT::loadSources(std::string &iFileName){
    // Open input file
    std::ifstream iFile;
    iFile.open(iFileName);
    if (iFile.fail()){
        std::ostringstream msg;
        msg << "loadSources(): Opening file '" << iFileName
            << "' failed, it either doesn't exist or is not accessible.";
        throw std::runtime_error(msg.str());
    }

    std::string str;
    std::stringstream ss;

    vecP x(new vec(2));
    int nRays;
    double angleMin, angleMax, step, tauMax;
    // Reinitialise values in case a line does not contain enough input values
    (*x)(0) = -1;
    (*x)(1) = -1;
    nRays = 0;
    angleMin = 0;
    angleMax = 0;
    step = 0;
    tauMax = 0;

    while(getline(iFile, str)){
        ss << str;
        ss >> (*x)(0) >> (*x)(1) >> nRays >> angleMin >> angleMax >> step >> tauMax;
        newSource(x, nRays, angleMin, angleMax, step, tauMax);
        ss.clear();
        // Reinitialise values in case a line does not contain enough input values
        (*x)(0) = -1;
        (*x)(1) = -1;
        nRays = 0;
        angleMin = 0;
        angleMax = 0;
        step = 0;
        tauMax = 0;
    }
    iFile.close();

    cout << "Total number of sources: " << getNSources() << endl;
}

/*=======================================================================
====== Write to output
=========================================================================*/

//  Write the ray trajectories of source nS in a file named "Source(nR).dat"
void GridRT::writeTrajectories(int const& nS){
    std::ofstream outputFile;
    std::string str = "Source" + std::to_string(nS) + ".dat";
    outputFile.open (str);
    int nR = source[nS]->getNRays();
    int nSteps = source[nS]->getNSteps();
    for (int i = 0; i < nR; i++){
        outputFile << "\"Ray " << i << "\"" << std::endl;
        int j = 0;
        vecP x(new vec(2, fill::zeros));
        while (j < nSteps && !std::isnan((*x)[0])){
            x.reset(std::move(source[nS]->getX(j, i).release()));
            outputFile << (*x)[0] << " " << (*x)[1] << std::endl; 
            j++;
        }
        outputFile << std::endl;
    }
    outputFile.close();
}

// Writes the trajectories for all sources in files named "Source(nR).dat" with nR the source index
void GridRT::writeTrajectories(void){
    int size = source.size();
    for (int i = 0; i < size; i++)
        writeTrajectories(i);
}

// Writes the dimensions of the domain as well as the number of computed sources in a file named "dimensions.dat"
void GridRT::writeDimensions(void){
    std::fstream outputFile;
    outputFile.open ("dimensions.dat", std::fstream::out);
    outputFile << "xMin=" << 0 << std::endl;
    outputFile << "xMax=" << (Nx-1)*dx << std::endl;
    outputFile << "yMin=" << 0 << std::endl;
    outputFile << "yMax=" << (Ny-1)*dy << std::endl;
    outputFile << "nSources=" << source.size();
    outputFile.close();
}


} 

